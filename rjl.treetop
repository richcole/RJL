grammar RJL

  rule blk
    open_brace a:args pipe stmts:statements close_brace {
      def node
        [:blk, a.node, stmts.node]
      end
    }
  end

  rule float
    w [0-9]+ "." [0-9]+ ( [eE] "-"? digits )? {
      def node
        [:float, self.text_value.to_f]
      end
    }
  end

  rule open_brace
    w "{"
  end

  rule close_brace
    w "}"
  end

  rule pipe
    w "|" 
  end

  rule args
    ident* {
      def node
        nodes(self, [])
      end
    }
  end 

  rule aident
    w t:([a-zA-Z] [a-zA-Z0-9]*) w "=" { 
      def node
        [:aident, t.text_value]
      end
    }
  end

  rule sident
    w t:([a-zA-Z] [a-zA-Z0-9]*) ":" { 
      def node
        [:sident, t.text_value]
      end
    }
  end

  rule ident
    w t:([a-zA-Z] [a-zA-Z0-9]*) { 
      def node
        [:ident, t.text_value]
      end
    }
  end

  rule digits
    w t:[0-9]+ {
    }
  end

  rule string
    w ["] t:([^"]*) ["]  {
      def node
        [:string, t.text_value]
      end
    }
  end

  rule w
    [\000\011\012\014\015\040]* {
    }
  end

  rule statements
    (expr_chain semi)* expr_chain? {
      def node
        [:stmts, nodes(self, [])]
      end
    }    
  end

  rule semi
    w ";" {
    }
  end

  rule operator
    w t:([!?@#$%^&*+-]+) {
      def node
        t.text_value
      end
    }
  end

  rule eq
    w "=" {
    }
  end

  rule group
    w "(" e:expr w ")" {
      def node
        [:group, e.node]
      end
    }
  end	

  rule assign
    s:aident e:expr {
      def node
        [:assign, s.node, e.node ]
      end
    }
  end    

  rule call
    s:sident e:expr {
      def node
        [:call, s.node, e.node ]
      end
    }
  end

  rule op_expr
    o:operator e:expr {
      def node
        [:osend, o.node, e.node] 
      end
    }
  end

  rule expr
    ( assign / call / float / ident / string / group / blk ) {
      def node
        [:expr, nodes(self, [])] 
      end
    }
  end

  rule expr_chain
    expr ( assign / call / ident / op_expr )* {
      def node
        [:expr_chain, nodes(self, []) ]
      end
    }
  end

end