One of the difficulties of RJL presently is that it is not known at
compile time how many arguments will be comsumed by a function
invocation.

To fix this we can change to a C like notation

  { sys |
    fib = { x | 
      if ( x <= 1 ) { 
        return x; 
      }
      else {
        return fib(x-1) + fib(x-2)
      };
    };
    sys.print(fib(12))
  }

This has a lot of brackets. How important is it really to know how
many stack entities are consumed by a send?

The idea is to be able to inline a send based on some quick check of
the object.

But with such a highly dynamic language any object modification might
invalidate an inlining.

This leads one to the introduction of a class based implementation
rather than an object based implementation. Thus one can check the
class of an object to determine inlining.

Maybe inlining has more to do with implementing implicit classes than
it has to do with a fixed number of arguments.



  

