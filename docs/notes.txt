
-- Notes on this file

This file is organized as a set of notes. I generally add notes at the
top of file. I also revise and prune older notes when they're no
longer valid.

-- Statements to be able to pop

Currently each time a statement is executed it leaves behind a little
poo on the stack. Statements should pop the poo unless there is a
return statement following otherwise the stack will grow.

A concequence of this is that an array generating construct is
somewhat easier to create since we're already creating it the stack.

-- Non local returns code removed

The non local returns code has been removed. Tests are passing again.

It would seem now that the return statement within the language is
pointless since the last value on the stack is returned.

Return statements have also been removed from the language. 

-- Non local returns

Following the discussion included later in this file I've decided to
remove non-local returns because they have very complex behaviour when
more than one of them exists on the stack and they don't play well
with exceptions.

-- Work on exceptions

Currently arguments are read from the return point stack. The top
level frame previously didn't have a return frame and so it wasn't
possible to push onto it. So I added a parent frame to the top level
frame to allow this.

Adding support for try catch blocks in the parser.

Added support for detecting parse errors, fixed an error in test_012.r
and now the test fails because the second return statement jumps out
too many levels.

Some later tests are also broken. They previously worked but had
parse errors when the code was parsed.

-- Thoughts on argument passing

Currently argument passing is destructive to the calling frames
stack. That seems a bit unsafe. If there is disagreement between the
number of items passed then the callers stack frame will be messed
with.

An alternative is to construct an argument array for every method call
and to pass that during construction of the child frame.

-- Added a mark and sweep garbage collector

All tests passing with valgrind. Added a mark and sweep gc which is run every
100 instructions from the interp loop at present. Seems to work ok.

Next step is to write some slightly longer test programs and perhaps some support 
for a basic debugger.

-- The program compiles again

The program compiles again and even runs a few tests after a massive
refactor that removes the use of global variables from the program.

-- Global Variables

Currently the interpreter has a number of global variables and global
functions. Can we get rid of these global functions and global
variables?

For this to occur the symbol table needs to be passed on the stack to
pretty much all functions.

I also want to get rid of fixnums. They just complicate the current
design and should wait for jit. For the time being all numbers should
be boxed.

As part of introducing contexts I'm also making head and cpp files.

-- First steps towards GC

There is an excellent survey on garbage collection techniques called
"Uniprocessor garbage collection techniques" by Paul R Wilson. It
explains that generational garbage collectors must keep track of dirty
bits when performing pointer assignment in order to keep track of
which objects in the new generation are supported by references from
objects in the old generation.

The first attempt at a GC that I will write will be a simple mark and
sweek garbage collector. I'm going to start simple because writing and
testing a GC is not easy and mark and sweep will likely work for the 

-- Non-local returns

A non-local return is a return inside a block that returns to the
lexical scope of the block.

  fib:: { x |
    if ( x <= 1 ) {
      return 1;
    }
    return (fib: (x-1)) + (fib: (x-2));
  }

The first return is non local because it returns from the function not
the if statement.

If one doesn't support non-local returns then one cannot write code
like the above, instead one has to be more turn oriented and do
something like:

  fib:: { x |
    if ( x <= 1 ) {
      1;
    }
    else {
      (fib: (x-1)) + (fib: (x-2));
    };
  };

Here I am assuming that a block returns the top of the stack upon
return. Another place that one wants non-local returns is in iterators

  first:: { is_match: |
    self each: { x | 
      if ( is_match: x ) {
        return x;
      };
    };
  };

This is even more pathalogical because it is the first function that
one wants to return from. Thus one needs some way to specify that a
function is a non-local return site or not. One could do that
syntactically.

  first:: {| is_match: |
    self each: { x | 
      if ( is_match: x ) {
        return x;
      };
    };
  |};
    
Non-local return is the default for a block. It is overridden by using
{| and |} as the block delimiters. This combines well with a system
that returns the last stack item in the block by default because most
code will not have a return statement in it.

It does mean that the introduction of a return statement will mean
using the return site block element. Maybe a convention will arise
over time as to when to use each type.

Another issue with non-local returns is whether they go back up the
call stack or they keep a link via the lexical scope. For example

 {| button |
   button on_click: { return 1 };
 |}

The button will likely stash away the on_click function. The non-local
return can either return to the definition site or it can skip up the
call chain until it hits a non-local block.

It makes more logical sense to skip up the call chain until one hits a
non-local block. Another example of that of finally blocks. Finally
blocks should be executed in the presense of non-local returns.

 File open:mode:do:: { filename mode block: |
   file = File open: filename mode: mode;
   try {
     block: file;
   }
   finally {
     file close;
   }
 }
   
This raises another issue. Non local returns fight one another. So for
example if a block is passed into some code and that code is marked as
a non-local return block, that will catch a non-local return intended
for a higher scope level.

Finally blocks are tricky to support because they need to remember
that there is an exception being thrown and rethrow it. A finally
block is like this

  try {
    ... some code
  }
  catch { ex | 
    do: { 
      ... finally block
    }
    throw: ex;
  }
    
Rethrowing of an exception that has an exception trace needs not overwrite
the throw location.

So the simplest thing is to not support non-local returns because they
interact oddly with exceptions and they can fight one another.


-- Needed features

Next more tests around operators.

Exceptions are currently not working or tested. The top level catch
doesn't even work.

The parser doesn't error out when there are errors this should be
fixed.

