
-- Notes on this file

This file is organized as a set of notes. I generally add notes at the
top of file. I also revise and prune older notes when they're no
longer valid.

-- Work on exceptions

Currently arguments are read from the return point stack. The top
level frame previously didn't have a return frame and so it wasn't
possible to push onto it. So I added a parent frame to the top level
frame to allow this.

Adding support for try catch blocks in the parser.

Added support for detecting parse errors, fixed an error in test_012.r
and now the test fails because the second return statement jumps out
too many levels.

Some later tests are also broken. They previously worked but had
parse errors when the code was parsed.

-- Thoughts on argument passing

Currently argument passing is destructive to the calling frames
stack. That seems a bit unsafe. If there is disagreement between the
number of items passed then the callers stack frame will be messed
with.

An alternative is to construct an argument array for every method call
and to pass that during construction of the child frame.

-- Added a mark and sweep garbage collector

All tests passing with valgrind. Added a mark and sweep gc which is run every
100 instructions from the interp loop at present. Seems to work ok.

Next step is to write some slightly longer test programs and perhaps some support 
for a basic debugger.

-- The program compiles again

The program compiles again and even runs a few tests after a massive
refactor that removes the use of global variables from the program.

-- Global Variables

Currently the interpreter has a number of global variables and global
functions. Can we get rid of these global functions and global
variables?

For this to occur the symbol table needs to be passed on the stack to
pretty much all functions.

I also want to get rid of fixnums. They just complicate the current
design and should wait for jit. For the time being all numbers should
be boxed.

As part of introducing contexts I'm also making head and cpp files.

-- First steps towards GC

There is an excellent survey on garbage collection techniques called
"Uniprocessor garbage collection techniques" by Paul R Wilson. It
explains that generational garbage collectors must keep track of dirty
bits when performing pointer assignment in order to keep track of
which objects in the new generation are supported by references from
objects in the old generation.

The first attempt at a GC that I will write will be a simple mark and
sweek garbage collector. I'm going to start simple because writing and
testing a GC is not easy and mark and sweep will likely work for the 

-- Non local returns

Non local returns work by marking blocks created for if and while statements
as local blocks. Non local returns then jump back up until they find a block
that is not local to return from.

In smalltalk it appears that non-local returns occur even in blocks
that are create that are not method blocks, but RJL has no way to
distinguish method from non method blocks since assignment is a method
call.

So for example in RJL

  xs each { x | return x; };

This is effectively a local return. The reason is that it isn't clear
to where blocks should return when they are nested.

We might similarly be defining a function

  xs x: { return self x; };

which we would expect to return. Also with nested structures

  xs x: {
    if ( x > 1 ) {
      if ( x > 2 ) {
        return 3;
      }
    }
  }

What if we make the non-local return site the enclosing scope and have
it be inherrited for if and while constructs.

  first: { self each { x | return x } }



-- Needed features

Next more tests around operators.

Exceptions are currently not working or tested. The top level catch
doesn't even work.

The parser doesn't error out when there are errors this should be
fixed.

