=== tr --- translate string

This program is an example of literate programming in RJL. Any
non-indented line is considered to be documentation and follows a
simple wiki style. Any indented line is part of the code.

This module defines a single function named tr. The module has a
section for defining types, tests and dependencies.

You notices that all statements in RJL are executable code including
type annotations. In RJL these things, types, tests and dependencies
are all provided by libraries.

Lets begin with the outer definition. It is a block map. That is a
block that when executed returns an object with fields defined by
assignments. The block takes sys as an argument which provides access
to the runtime.

  [ sys |

The next section defines the types of the module being returned.

    types = { type |
      type tr = function [| string ; string ; string |] returns string
    };

This block will be executed both with an argument type which is used
to define types and within a lexical scope which provides access to
existing types.

The lexical closure is expected to define values for function and
string. 'returns' is a method call on the object returned by function
which annotates the returned type object with a return type.

Next we define a couple of tests for the module.

    tests = { test |
      test { tr "ab" "bc" "abc" } expects "bcc" ;
      test { tr "ab" "b" "abc"  } throws ArgumentError ;
    };

Next we define the dependencies. This block is passed an object called
'it' which is used to declare dependencies.

    depends = { it |
      it has_name "org.richcole.examples.tr";
      it has_version "0.1";
      it requires [| "std.string" ; "std.function" ; "std.map" ; "std.errors" |];
    ];

The module being defined is called "org.richcole.example.tr". This
module requires three modules to run. These are std.string,
std.function and std.map.

Next comes the implementation for the module. In a more general
setting one might have several implementations for a single type
definition, however in this case we have the implementation and type
definitions all defined in one place.

We are not commenting at this stage on how a given runtime system will
locate and install the dependencies neccessary to run a module.

    module = [
      tr = { 
        from_set : string ; 
        to_set : string ; 
        str : string 
      |

tr takes three arguments, from_set, to_set, and str. 

        if (from_set length) != (to_set_length) {
          throw ArgumentError "Expected from_set and to_set to have the same length"
        }
        return str map { x | 
          if ( index = from_set index x ) {
            return to_set at index;
          }
          else {
            return x;
          }
        }
      }
    ]

The function first checks its arguments are the same length and if
they are not throws ArgumentError which is defined in std.errors.

  ]

